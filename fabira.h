#ifndef FABIRA_H
#define FABIRA_H

typedef struct prng_state {
  uint32_t table[256];
  uint32_t counter;
} prng_state;

#define ROTR(a, c) (((a) >> c) | ((a) << (32 - c)))

// The size must be a multiple of 4 bytes.
static inline void prng_gen(prng_state *state, uint8_t *buf, size_t size) {
  uint32_t *b = (uint32_t *)buf;
  prng_state *s = state;
  for (size_t i = 0; i < size / 4; i++) {
    uint32_t t = ROTR(s->table[s->table[s->counter & 255] & 255], 15);
    b[i] = s->table[(++s->counter) & 255] += t + s->counter;
  }
}

// Nothing up my sleeve: those are the hex digits of Î¦,
// the least approximable irrational number.
// $ echo 'scale=1234;obase=16;(sqrt(5)-1)/2' | bc
static uint32_t phi[256] = {
  0x9E3779B9, 0x7F4A7C15, 0xF39CC060, 0x5CEDC834, 0x1082276B, 0xF3A27251, 0xF86C6A11, 0xD0C18E95,
  0x2767F0B1, 0x53D27B7F, 0x0347045B, 0x5BF1827F, 0x01886F09, 0x28403002, 0xC1D64BA4, 0x0F335E36,
  0xF06AD7AE, 0x9717877E, 0x85839D6E, 0xFFBD7DC6, 0x64D325D1, 0xC5371682, 0xCADD0CCC, 0xFDFFBBE1,
  0x626E33B8, 0xD04B4331, 0xBBF73C79, 0x0D94F79D, 0x471C4AB3, 0xED3D82A5, 0xFEC50770, 0x5E4AE6E5,
  0xE73A9B91, 0xF3AA4DB2, 0x87AE44F3, 0x32E923A7, 0x3CB91648, 0xE428E975, 0xA3781EB0, 0x1B49D867,
  0x4FA15084, 0x19E0EAA4, 0x038B352D, 0x9BAD30F4, 0x485B71A8, 0xEF64452A, 0x0DD40DC8, 0xCB8F9A2D,
  0x4C514F1B, 0x229DCAA2, 0x22AC268E, 0x9666E4A8, 0x66769145, 0xF5F5880A, 0x9D0ACD3B, 0x9E8C682F,
  0x4F810320, 0xABEB9403, 0x4E70F216, 0x08C061AB, 0x1C1CAEF1, 0xEBDCEFBC, 0x72134ECF, 0x06ED82BF,

  0xB7D8EB1A, 0x41901D65, 0xF5C8CAB2, 0xACCBC32E, 0xAB1FBE82, 0x84F2B44B, 0xA2E834C5, 0x893A39EA,
  0x7865443F, 0x489C37F8, 0x742ACD89, 0x5AFD87B4, 0x67D22A40, 0xD098F30D, 0xD2CAFDEB, 0x3ABB3A13,
  0x507B46B3, 0xD757FC04, 0x001906E1, 0x767D40C3, 0xA3792A26, 0xEEEF2AB5, 0xBD6685B9, 0x15B56294,
  0x00FAA684, 0xECBA752D, 0xDDCB5D18, 0x576D77B6, 0x52AC0D99, 0x99736866, 0x04128F0C, 0xD4274359,
  0x6DEB2D42, 0xC789D64B, 0x92658610, 0xB5B95C71, 0x9ADEB8CE, 0x28732634, 0x4E31D59A, 0x59963220, 
  0xB1A4C427, 0x71D454EC, 0x78F12393, 0xBFB4AC54, 0x188E5911, 0x3D7C3544, 0x1F15AA34, 0xA1140703, 
  0x5F006FC3, 0xAD70FC0D, 0x6331C6D4, 0x79F484BF, 0x39CBFBD9, 0x5E664E39, 0xBEBDC5B0, 0x9D9D5B8F, 
  0x8905D980, 0x5C819945, 0x7D444A90, 0x9316CC58, 0xD38B3A25, 0xC714BE8D, 0x422964E9, 0x724C033B, 

  0x6748ACBC, 0x2E05CAAF, 0x737C9562, 0x2E6483FA, 0x0707999A, 0xFC482995, 0x1701C6ED, 0x5F27CE23, 
  0x17709655, 0x41F5F287, 0x97F2FECB, 0xD984D343, 0x5CE547C8, 0x8C38466E, 0x28652356, 0x83D4447E, 
  0x4B327579, 0x03058CA1, 0x1A903F3B, 0xAA386493, 0x2B80A7D0, 0x2D61B50C, 0x1FF281D5, 0xDD2947DA, 
  0x4624BBC7, 0xC7B94962, 0x717AED28, 0x4395C42F, 0x253C17F4, 0x92F401BB, 0x6C17A95C, 0x3296B424, 
  0xDB05AFA8, 0xE7AD2561, 0xACA1F4FD, 0x6E0EB57F, 0x831E4022, 0x7FBACD46, 0x7FF8B7F8, 0x4370AEF7, 
  0x11857634, 0xD0CF4189, 0x002DDE87, 0x87576C63, 0x1F0B9A17, 0x3C16B80E, 0x7D941C12, 0x8A540C91, 
  0xD33A1DAF, 0x0F022298, 0x6E3C7661, 0xB2A7B374, 0xDC06D839, 0x6659E0FD, 0xE9B7B41D, 0xC1BBB0F4, 
  0x2988D4D2, 0x525906BD, 0xF64A6EA5, 0xB159F2AD, 0xF7C883CE, 0x8C4808A9, 0xB46EB960, 0xF7419201, 

  0x0862BD1C, 0x306500C6, 0x795A0A29, 0xDF4A34D4, 0x2B1A418A, 0x9FBCABD5, 0x1E1887AA, 0x0F8EBDF4, 
  0x452D6EFB, 0x8D2948D8, 0x878256E2, 0xC6C33DC8, 0xCA89D68E, 0x06AEABD5, 0x6BCA17DE, 0xA2358E44, 
  0x3B567201, 0xDBE25E06, 0xA7451A73, 0x6B14CFE3, 0xAF438522, 0x186524DA, 0xD69F054B, 0x61CDBF1B, 
  0xA9A54F46, 0xFF7A2A1E, 0x5090E0A2, 0x6DBE7766, 0xEBF40475, 0xA2F166AB, 0x6B1791B0, 0xEE0B48D8, 
  0x63C08F80, 0x9967AC68, 0xA158A6B4, 0xEEFE4FAE, 0x8EB1D32C, 0xFA6A4573, 0x468C1374, 0x01262AB7, 
  0x893A30CB, 0x015245B7, 0x6FA16CF8, 0x9DB93647, 0xBB74E258, 0x1AE8823D, 0x14C0343E, 0xFB790B35, 
  0x76421642, 0x8D6E9856, 0xDD074EE6, 0xF411EE1B, 0x5DD2A670, 0xCCE122BF, 0x868BE818, 0x525E08F5, 
  0xB8B3D940, 0x252B853B, 0x7248A83A, 0xA561610F, 0x17A35FC8, 0x3E542A94, 0xFCB71694, 0xC229EF98, 
};

void prng_init(prng_state *state, uint64_t seed[4]) {
  memcpy(state->table, phi, sizeof(phi));
  state->counter = 0;

  uint32_t *seed32 = (uint32_t *)seed;
  uint32_t diffuse = 0;
  char bi = 0;
  for (char si = 0; si < 8; si++) {
    for (char i = 0; i < 3; i++) {
      // Each rotation ensures that the XORs are noncommutative.
      diffuse ^= ROTR(state->table[(diffuse ^ seed32[si]) & 255], bi++);
      seed32[si] >>= 8;
    }
  }
  for (int i = 0; i < 256; i++) {
    state->table[i] ^= diffuse;
  }
}
#endif // FABIRA_SCALAR_H
